use std::io; // io - библиотека ввода/вывода, она является частью стандартной библиотеки std 
             // io - in/out, std - standard
             // Без них не получилось бы сделать ввод с клавы и чтение
             // use ну понятно, чтобы включить то, что не было изначально включено в программу 
             // у rust есть "прелюдия", то что работает всегда, а если что-то еще нужно допом - вот нужно писать это use 
             // короче как import библиотеки в питоне, только тут библиотеки - это базовый функционал
use rand::Rng;  // библиотека рандом  
use std::cmp::Ordering;         // библиотека упорядочевания
                                // имеет варианты Less, Greater, Equal 

fn main() {
    println!("Guess the number!");

    let secret_number = rand::thread_rng().gen_range(1..=100); // Gen_range из библиотеки rand, наш диапазон

    //println!("The secret number is: {secret_number}");

    loop {
        println!("Please input your guess.");

        let mut guess = String::new(); // let (пусть) создает переменную и позволяет привязать к ней значение
                                    // например let apples = 5 привязывает к apples 5 
                                    // mut (mutable - изменяемый) делает переменную изменяемой 
                                    // guess - просто имя переменной 
                                    // String - тип строки из стандартной библиотеки

                                    // Синтаксис :: в строке ::new указывает, 
                                    // что new является ассоциированной функцией типа String!

                                    // new создает новое значение какого либо типа

        io::stdin()                    // мы ввели in/out (io) модуль в начале
                                    // теперь делаем standard_in (stdin) из этого модуля
            .read_line(&mut guess)     // читаем строку для получения ввода от пользователя
                                    // Тут mut нужен, потому что мы теперь записываем (в память компа) 
                                    // наше новое значение, полученное от пользователя
                                    // т.е. сначала мы создали guess, сделали его изменяемым, чтобы вписать
                                    // строку пользователя, потом считываем что пользователь написал
                                    // и тоже делаем изменяемым, чтобы записать в guess

                                    // В let mut guess — объявляем переменную изменяемой
                                    // В &mut guess — даём функции разрешение её изменять

                                    // & - значит, что аргумент является ссылкой, т.е. к нему можно обратиться
                                    // из разных частей кода (очень важная штука в rust)  

                                    // read_line помещает всё, что вводит пользователь, 
                                    // в строку, которую мы ему передаём, но также возвращает значение Result
            .expect("Failed to read line");

            let guess: u32 = guess  // Проверяет, что ввели число на входе
                                    // а не строку
                                    // без этой строки программа не компилируется
                                    // u32 - беззнаковое 32битное число 
                                    // мы опять создали переменную с именет guess
                                    // самая последняя guess затеняет предыдущую
            .trim()                                                                                   
                                    // метод trim удаляет пробелы в строке
                                    // и новую строку \n тоже
                                    // остается только число
            .parse()                
                                    // метод parse преобразует строку в другой тип
            .expect("Please type a number!");  
                                    // в норме эта часть записана в одну строку 
                                    // let guess: u32 = guess.trim().parse().expect("Please type a number!");



        println!("You guessed: {guess}");
        match guess.cmp(&secret_number) {   // Сравнивает по очереди ввод с нашим секретным числом
                                            // cpm (compare) идет сначала в Less (из библиотеки) -> получает не Less,
                                            // идет в Greater -> получае не Greater -> идет в Equal 
        Ordering::Less => println!("Too small!"), // важно, чтобы наш номер был числом, а не строкой
            Ordering::Greater => println!("Too big!"),
            Ordering::Equal => {
                println!("You win!");
                break;
            }
        }
    }
}
